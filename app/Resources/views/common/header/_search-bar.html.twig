{% set categories = categoryTree() %}

<div id="search-bar" class="search-bar" v-cloak>
    <div class="container">
        <div class="wrapper">

            <form action="{{ path('search') }}" method="get" class="search-bar-form" autocomplete="off">
                <input type="hidden" name="selected_category_id" v-model="selectedCategoryId">

                {# query #}
                <div class="query-input-group">

                    {# query text input #}
                    <div class="product-search-input-group">
                        <input class="form-control" type="text" name="q" placeholder="Rechercher..." v-model="query" @keyup.esc="query = ''">

                        {# auto-complete suggestions #}
                        <div class="product-suggestions">
                            <ul class="content" v-if="productSuggestions.length">
                                <li class="suggestion-item" v-for="suggestion in productSuggestions">
                                    <a href="#"
                                       class="suggestion"
                                       @click.prevent="selectSuggestion(suggestion)"
                                       v-text="suggestion.name"
                                       tabindex="0"
                                    ></a>
                                </li>
                            </ul>
                        </div>
                    </div>

                    {# categoriy selector (display only root categories) #}
                    <select class="category-picker form-control" title="Sélectionnez une catégorie" @change="selectCategory()">
                        <option class="default-option" value="" selected disabled>Toutes les catégories</option>

                        {% for category in categories %}
                            <option value="{{ category.category.id }}">{{ category.category.name }}</option>
                        {% endfor %}
                    </select>

                    {# submit button #}
                    <button class="btn btn-primary" type="submit">
                        <i class="fa fa-search"></i>
                        <span class="hidden-xs">Rechercher</span>
                    </button>
                </div>

                {# geolocation #}
                <div class="geo-input-group">

                    {# forward the geoloc to search page #}
                    <input type="hidden" name="geo[lat]" v-model="geoFilter.lat">
                    <input type="hidden" name="geo[lng]" v-model="geoFilter.lng">

                    {# city, department #}
                    <input type="text" name="geo[label]" v-model="geoFilter.label" class="form-control" id="geofilter-label" placeholder="Ville, département...">

                    {# submit button #}
                    <button type="button" class="btn btn-primary" @click="geoLocateMe">
                        <i class="fa fa-map-marker"></i>
                        <span class="hidden-xs">Me localiser</span>
                    </button>
                </div>
            </form>
        </div>
    </div>
</div>

<script>
    $(function() {

        let search = new SearchClient('{{ apiBaseUrl }}catalog/search/products', '{{ apiBaseUrl }}catalog/search/products/autocomplete');
        let urlParameters = search.restoreSearchFromUrl(); // used in search page

        let vm = new Vue({
            el: '#search-bar',

            data: {
                selectedCategoryId: '',
                productSuggestions: [],
                query: urlParameters.query || '',
                geoFilter: urlParameters.geoFilter || {},
            },

            methods: {
                selectCategory: function() {
                    let $selectedCategory = $(".category-picker option:selected");
                    this.selectedCategoryId = $selectedCategory.val();
                },

                // _.debounce is a function provided by lodash to limit how often a particularly expensive operation can be run.
                productAutocomplete: _.debounce(function() {

                    let self = this;

                    search.autocomplete(this.query, function (results) {
                        self.productSuggestions = results;
                    });
                },
                    // how long to wait for user to stop typing (in ms)
                    200
                ),

                // watch user query input to display corresponding product suggestions (auto-completion)
                initProductAutocomplete: function() {
                    let self = this;
                    let $queryInput = $('[name="q"]');
                    let $queryInputGroup = $('.product-suggestions');

                    // show suggestions when:
                    // - user has typed at least 3 characters
                    // - there are three characters and user clicks in the input field
                    $queryInput.on('keyup click', function() {
                        if (self.query.length >= 3) {
                            $queryInputGroup.removeClass('hidden');
                            self.productAutocomplete();
                        } else {
                            // don't fill/show suggestions if user input isn't specific enough
                            self.productSuggestions = [];
                        }
                    });

                    // hide suggestions when user has clicked somewhere else
                    $(document).on('click', function(e) {

                        // doesn't hide if user has clicked on a suggestion or in the input field
                        let $target = $(e.target);
                        if ($target.hasClass('suggestion') || $target.attr('name') === 'q') {
                            return;
                        }

                        $queryInputGroup.addClass('hidden');
                    });
                },

                selectSuggestion: function(suggestion) {

                    // update 'query' v-model and add suggestion into query input box
                    this.query = suggestion.name;

                    // hide suggestions
                    this.productSuggestions = [];
                },

                geoLocateMe: function() {

                    if (! 'geolocation' in navigator) {
                        notification.createAlert("Géolocalisation impossible.", "danger");
                        return;
                    }

                    navigator.geolocation.getCurrentPosition(function(position) {

                        vm.geoFilter = {
                            lat: position.coords.latitude,
                            lng: position.coords.longitude,
                            label: "Autour de moi"
                        };

                        // success message
                        notification.createAlert('Rechercher "Autour de moi".', "success");

                    }, function (error) {

                        switch(error.code) {
                            case error.PERMISSION_DENIED:
                                notification.createAlert("Géolocalisation refusée.", "danger");
                                break;
                            default:
                                notification.createAlert("Erreur de géolocalisation.", "danger");
                                break;
                        }
                    });
                },

                // called when the user autocompletes a place with Google Maps
                geolocAutocompleted: function () {

                    let place = this.googleMapsAutocomplete.getPlace();

                    if (! place.geometry) {

                        // user entered a place that was not suggested and pressed Enter, or the request failed
                        this.geoFilter = {};
                        return;
                    }

                    this.geoFilter = {
                        lat: place.geometry.location.lat(),
                        lng: place.geometry.location.lng(),
                        label: place.name
                    };
                },
            },

            mounted: function () {

                // initialize the Google Maps autocomplete in search bar
                let labelInput = document.getElementById('geofilter-label');
                this.googleMapsAutocomplete = new google.maps.places.Autocomplete(labelInput);
                this.googleMapsAutocomplete.addListener('place_changed', this.geolocAutocompleted);

                // input field behaviour
                this.initProductAutocomplete();
            }
        });
    });
</script>
