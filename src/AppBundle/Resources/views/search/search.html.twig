{% extends '@App/layout.html.twig' %}

{% block body %}
    <div id="search-page" v-cloak>

        {# search results number #}
        <div v-if="pagination.nbResults" v-text="pagination.nbResults"></div>

        {# current category name #}
        {% if currentCategory|default %}
            <h2>{{ currentCategory.name }}</h2>
        {% endif %}

        {# sorts #}
        <button type="button" @click="setSort(null, null)">{{ 'search.sort.relevance'|trans }}</button>
        <button type="button" @click="setSort('name', 'asc')">{{ 'search.sort.alpha_asc'|trans }}</button>
        <button type="button" @click="setSort('name', 'desc')">{{ 'search.sort.alpha_desc'|trans }}</button>
        <button type="button" @click="setSort('price', 'asc')">{{ 'search.sort.price_asc'|trans }}</button>
        <button type="button" @click="setSort('price', 'desc')">{{ 'search.sort.price_desc'|trans }}</button>


        {# results by page #}
        <button type="button" @click="changeResultsNumber(12)">12</button>
        <button type="button" @click="changeResultsNumber(24)">24</button>
        <button type="button" @click="changeResultsNumber(48)">48</button>


        <div class="search-block">

            {# sidebar #}
            <div class="sidebar">
                {% include '@App/search/sidebar/_sidebar.html.twig' %}
            </div>


            {# search result #}
            <div class="search-result">

                {# fetched products #}
                <div class="products">
                    {% include('@App/common/product/_search-card.html.twig') %}
                </div>

                {# pagination #}
                {% include('@App/common/_pagination.html.twig') %}
            </div>
        </div>
    </div>

    {% include '@App/common/product/_modal_add-to-basket.html.twig' %}

    {# price slider template #}
    <template id="slider-template">
        <div class="range-slider">
            <div class="range-slider-wrapper">
                <div id="facet-slider"></div>
                <div class="range-values">
                    <span class="facet-range-min" v-text="currentMin + ' €'"></span>
                    <span class="facet-range-max" v-text="currentMax + ' €'"></span>
                </div>
            </div>
        </div>
    </template>

{% endblock %}

{% block scripts %}

    <script>
        var urlParameters;

        var search = new SearchClient('{{ apiBaseUrl }}catalog/search/products', '{{ apiBaseUrl }}/catalog/search/products/autocomplete');
        urlParameters = search.restoreSearchFromUrl();

        Vue.filter('round', function(value) {
            return Math.round(value);
        });

        var vm = new Vue({
            el: '#search-page',
            delimiters: ['${','}'],
            data: {
                loading: true,
                products: [],
                query: urlParameters.query || '',
                pagination: {
                    page: urlParameters.page || 1,
                    resultsPerPage: urlParameters.resultsPerPage || 6
                },
                filters: urlParameters.filters || {{ filters|default({})|json_encode|raw }},
                sorting: urlParameters.sorting || {},
                facets: [],
                currentUrl: window.location.href,
                geoFilter: urlParameters.geoFilter,
                calculatedPages: this.calculatePages,
            },
            methods: {
                refresh: function () {
                    this.loading = true;
                    var self = this;

                    search.searchProducts(this.query, this.pagination.page, this.pagination.resultsPerPage, this.filters, this.sorting, this.geoFilter, {}, function (response) {
                        self.loading = false;
                        self.products = response.results;
                        self.pagination = response.pagination;

                        // filter returned facets
                        Object.keys(response.facets).map(function (attributeId) {
                            var variants = response.facets[attributeId];
                            Object.keys(variants).map(function (variantId) {

                                // remove reverse attribute search (∅)
                                if (variantId === 'values') {
                                    for (var valueId in response.facets[attributeId][variantId]) {

                                        // remove ∅ variant
                                        if (valueId === '∅') {
                                            delete response.facets[attributeId][variantId][valueId];
                                        }
                                    }
                                }
                            });
                        });

                        self.facets = response.facets;

                        search.saveSearchInUrl(self.query, self.pagination.page, self.pagination.resultsPerPage, self.filters, self.sorting, self.geoFilter);

                        Vue.nextTick(function () {
                            // open category tree
                            self.refreshCategoryTree();
                        });
                    });
                },

                isChecked: function(facetName, variantName) {
                    return this.filters.hasOwnProperty(facetName) && this.filters[facetName] == variantName;
                },

                setSort: function(criteria, direction) {
                    if(criteria ===  null) {
                        this.sorting = null;
                    } else {
                        this.sorting = {};
                        this.sorting[criteria] = direction;
                    }
                    this.refresh();
                },

                goToPage: function (page) {
                    page = Math.max(1, page); // cannot go below page 1
                    page = Math.min(this.pagination.nbPages, page); // cannot go over total number of pages
                    this.pagination.page = page;

                    // got to page top
                    var $container = $('html, body');
                    var $ref = $("#search-page");
                    $container.animate({ scrollTop: $ref.offset().top - $container.offset().top }, 'fast');

                    this.refresh();
                },

                toggleFilter: function (facetName, variantName) {
                    if (this.filters.hasOwnProperty(facetName) && this.filters[facetName] == variantName) {
                        // Clear filter
                        Vue.delete(this.filters, facetName);
                    } else {
                        // Set filter
                        Vue.set(this.filters, facetName, variantName);
                    }
                    this.refresh();
                },

                changeResultsNumber: function (_resultsPerPage) {
                    this.pagination.resultsPerPage = _resultsPerPage;
                    this.refresh();
                },

                updateNumericFilter: function (facetName, min, max) {
                    if (!this.filters[facetName]) {
                        this.filters[facetName] = {};
                    }
                    this.filters[facetName]['min'] = min;
                    this.filters[facetName]['max'] = max;
                    this.refresh();
                },

                clearFilters: function () {
                    // Clear everything except the selected category
                    for (var property in this.filters) {
                        if (property !== 'categories' && this.filters.hasOwnProperty(property)) {
                            Vue.delete(this.filters, property);
                        }
                    }

                    this.refresh();
                },

                imageStyle: function(product) {
                    return {
                        backgroundImage: 'url(' + this.imageUrl(product) + ')',
                        backgroundRepeat: 'no-repeat',
                        backgroundPosition: 'center',
                        backgroundSize: 'cover',
                    }
                },

                imageUrl: function (product, dimension) {
                    if(product.mainImage != null) {
                        return "{{ apiBaseUrl }}image/" + product.mainImage.id + "?w=" + dimension + "&h=" + dimension;
                    } else {
                        return "{{ asset('images/no-image.jpg') }}"
                    }
                },

                productUrl: function (product) {
                    categorySlugPath = [];
                    for (var i in product.categoryPath) {
                        categorySlugPath.push(product.categoryPath[i].slug);
                    }
                    return Routing.generate('product', {slug: product.slug, categoryPath: categorySlugPath.join('/')});
                },

                getDiscount: function(product) {
                    if(! product.crossedOutPrice) { return }

                    var oldPrice = product.crossedOutPrice;
                    var newPrice = product.minimumPrice;
                    var discount = ((newPrice - oldPrice) * 100 / oldPrice);
                    return Math.round(discount);
                },

                isNewProduct: function (product) {
                    var aWeekAgo = moment().subtract(7, 'days');
                    return moment.unix(product.createdAt).isAfter(aWeekAgo);
                },

                refreshCategoryTree: function() {
                    var $selectedCategory = $('#categories .selected-category');

                    // open category tree
                    $selectedCategory.parents('#categories .collapse').addClass('in');

                    // cleanup
                    $('#categories .selected-category').removeClass('selected-category');
                    $('#categories .selected').removeClass('selected');

                    // ...and select the right ones
                    $selectedCategory.addClass('selected-category');
                    $selectedCategory.find(".category-name").first().addClass('selected');
                    $selectedCategory.parents('#categories .category').children(".category-name").addClass('selected');

                    // switch root category plus/minus icon
                    var rootCategoryIcon = $selectedCategory.parents('#categories .category').find(".glyphicon-plus");
                    rootCategoryIcon.toggleClass("glyphicon-plus glyphicon-minus");
                },

                isCurrentCategory: function(categoryId) {
                    return this.filters['categories'] == categoryId;
                },

                /**
                 * Add the product to the basket
                 */
                submitBasket: function(product) {
                    var productData = {
                        name: product.name,
                        price: product.minimumPrice,
                        image: this.imageUrl(product),
                    };
                    $.ajax({
                        type: "POST",
                        url: "{{ path('basket_add_product') }}",
                        data: { declinationId: product.productId, quantity: 1 },
                        success: function(response) {
                            hydrateModal(productData, 1, response.message);
                        }
                    });
                },

                range: function (a, b) {
                    var rangeArray = [];

                    for(var i = a; i < b; i++) {
                        rangeArray.push(i);
                    }

                    return rangeArray;
                },
            },

            mounted: function () {
                // Trigger the first refresh
                this.refresh();
            },

            filters: {
                price: helper.formatPrice
            }
        });

        // price slider
        Vue.component('slider', {
            template: '#slider-template',
            props: ['min', 'max'],
            data: function () {
                return {
                    currentMin: this.min,
                    currentMax: this.max
                }
            },
            activated: function () {
                var view = this;

                $('#facet-slider').slider({
                    range: true,
                    min: Math.floor(view.min),
                    max: Math.ceil(view.max),
                    values: [view.currentMin, view.currentMax],
                    slide: function (event, ui) {
                        view.currentMin = ui.values[0];
                        view.currentMax = ui.values[1];
                    },
                    stop: function () {
                        // Dispatch an event to the main view to update the search
                        view.$emit('update', view.currentMin, view.currentMax);
                    }
                });
            }
        });

        {# icons behaviours #}
        {# ================ #}

        // filter titles icons
        $(".sidebar-items").on("click", ".sidebar-item-label > [data-toggle='collapse']", function() {
            $(this).find(".glyphicon").toggleClass("glyphicon-menu-down glyphicon-menu-up");
        });

        // categorie names icons
        $(".category-name").on("click", function() {
            $(this).find(".glyphicon-plus, .glyphicon-minus").toggleClass("glyphicon-plus glyphicon-minus");
        });

        $(".category-name").on("click", function() {
            $(this).addClass("selected");
        });
    </script>

{% endblock %}
